// tic tac toe v0.2, revised on 20th October, 2018;

var turn = 0; //is used for checking players turns...
var box = document.getElementsByClassName("box"); // one variable for all nine boxes...
var board = document.getElementById("board");

var modalParent = document.getElementById('modal-container');
var modal = modalParent.getElementsByClassName('custom-modal')[0];

//this function rotates the board randomly ...
function rotateBoard() {
    var rotator = ["transform:rotate(0deg)", "transform:rotate(90deg)", "transform:rotate(180deg)", "transform:rotate(270deg)"];
    board.setAttribute("style", rotator[Math.floor(Math.random() * 4)]);
}

//  this function will check which palyer wins....
//	when we set the value of each X to 2, all winning chances are here like this.
//  result of each row/column/slash is 6 when X wins.
//	
//      6    6    6    6
//      "    "    "  //        
//	    2 |  2  | 2   =  6
//	 -----+-----+----
//	    2 |  2  | 2   =  6
//	 -----+-----+----
//      2 |  2  | 2   =  6
//      
// setting all O to value 5 will make a winning number to 15 from all sides, unless these seven results 
// is equal to 6 or 15 , its a tie match. lets see if the function works or not ....
//
//	   15    15   15   15 
//	    "    "    "  //
//	    5 |  5  | 5    = 15
//	 -----+-----+----
//	    5 |  5  | 5    = 15
//	 -----+-----+----
//      5 |  5  | 5    = 15


// this function handles the win results inside a popup;
var popUpWindow = function (playerImagePosition) {
    modalParent.style.opacity = '1';
    modalParent.style.zIndex = '100';
    modal.style.zIndex = '200';
    if (playerImagePosition === 'tie') {
        modal.getElementsByTagName('h2')[0].innerHTML = "It's a Tie";
    } else {
        modal.getElementsByClassName('player-won')[0].style.backgroundPositionX = playerImagePosition;
    }
    modal.getElementsByTagName('button')[0].addEventListener('click', function () {
        window.location.reload(true);
    });
};

function winCheck() {
    var rowOne
        = parseInt(box[0].dataset.playerType)
        + parseInt(box[1].dataset.playerType)
        + parseInt(box[2].dataset.playerType);
    var rowTwo
        = parseInt(box[3].dataset.playerType)
        + parseInt(box[4].dataset.playerType)
        + parseInt(box[5].dataset.playerType);
    var rowThree
        = parseInt(box[6].dataset.playerType)
        + parseInt(box[7].dataset.playerType)
        + parseInt(box[8].dataset.playerType);
    var colOne
        = parseInt(box[0].dataset.playerType)
        + parseInt(box[3].dataset.playerType)
        + parseInt(box[6].dataset.playerType);
    var colTwo
        = parseInt(box[1].dataset.playerType)
        + parseInt(box[4].dataset.playerType)
        + parseInt(box[7].dataset.playerType);
    var colThree
        = parseInt(box[2].dataset.playerType)
        + parseInt(box[5].dataset.playerType)
        + parseInt(box[8].dataset.playerType);
    var backSlash
        = parseInt(box[0].dataset.playerType)
        + parseInt(box[4].dataset.playerType)
        + parseInt(box[8].dataset.playerType);
    var forwardSlash
        = parseInt(box[2].dataset.playerType)
        + parseInt(box[4].dataset.playerType)
        + parseInt(box[6].dataset.playerType);

    var possibilities = [rowOne, rowTwo, rowThree, colOne, colTwo, colThree, backSlash, forwardSlash];

    // like explained above comments with diagram, any item from the above array should return 1 or 2 if a player
    // wins, it can return 2 because a player can sometimes win from 2 possible lines maximum;
    var xWin = possibilities.filter(scope => scope === 6);
    var oWin = possibilities.filter(scope => scope === 15);
    var tie  = possibilities.filter(scope => isNaN(scope));

    // now take care of who won the game
    if (xWin.length === 1 || xWin.length === 2) {
        popUpWindow('200%');
    } else if (oWin.length === 1 || oWin.length === 2) {
        popUpWindow('100%');
    } else if (tie.length === 0 && xWin.length === 0 && oWin.length === 0) {
        popUpWindow('tie');
    }

}

var turnCheck = function (event) {
    if (event.target.classList.contains('box')) {
        if (event.target.getAttribute('data-player-type') === null) {
            event.target.setAttribute('data-player-type', (turn % 2 === 0) ? 2 : 5);
            event.target.style.backgroundPosition = (turn % 2 === 0) ? '200% 0' : '100% 0';
            turn++;
            winCheck();
        }
    }
};

board.addEventListener('click', turnCheck);

// only for personal portfolio page;
document.body.addEventListener("dblclick", function reload() {
    location.reload(true);
});

// rotate the board when window loads;
rotateBoard();

//# sourceMappingURL=data:application/json;charset=utf8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbImFwcC5qcyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwiZmlsZSI6ImFwcC5taW4uanMiLCJzb3VyY2VzQ29udGVudCI6WyIvLyB0aWMgdGFjIHRvZSB2MC4yLCByZXZpc2VkIG9uIDIwdGggT2N0b2JlciwgMjAxODtcblxudmFyIHR1cm4gPSAwOyAvL2lzIHVzZWQgZm9yIGNoZWNraW5nIHBsYXllcnMgdHVybnMuLi5cbnZhciBib3ggPSBkb2N1bWVudC5nZXRFbGVtZW50c0J5Q2xhc3NOYW1lKFwiYm94XCIpOyAvLyBvbmUgdmFyaWFibGUgZm9yIGFsbCBuaW5lIGJveGVzLi4uXG52YXIgYm9hcmQgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChcImJvYXJkXCIpO1xuXG52YXIgbW9kYWxQYXJlbnQgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnbW9kYWwtY29udGFpbmVyJyk7XG52YXIgbW9kYWwgPSBtb2RhbFBhcmVudC5nZXRFbGVtZW50c0J5Q2xhc3NOYW1lKCdjdXN0b20tbW9kYWwnKVswXTtcblxuLy90aGlzIGZ1bmN0aW9uIHJvdGF0ZXMgdGhlIGJvYXJkIHJhbmRvbWx5IC4uLlxuZnVuY3Rpb24gcm90YXRlQm9hcmQoKSB7XG4gICAgdmFyIHJvdGF0b3IgPSBbXCJ0cmFuc2Zvcm06cm90YXRlKDBkZWcpXCIsIFwidHJhbnNmb3JtOnJvdGF0ZSg5MGRlZylcIiwgXCJ0cmFuc2Zvcm06cm90YXRlKDE4MGRlZylcIiwgXCJ0cmFuc2Zvcm06cm90YXRlKDI3MGRlZylcIl07XG4gICAgYm9hcmQuc2V0QXR0cmlidXRlKFwic3R5bGVcIiwgcm90YXRvcltNYXRoLmZsb29yKE1hdGgucmFuZG9tKCkgKiA0KV0pO1xufVxuXG4vLyAgdGhpcyBmdW5jdGlvbiB3aWxsIGNoZWNrIHdoaWNoIHBhbHllciB3aW5zLi4uLlxuLy9cdHdoZW4gd2Ugc2V0IHRoZSB2YWx1ZSBvZiBlYWNoIFggdG8gMiwgYWxsIHdpbm5pbmcgY2hhbmNlcyBhcmUgaGVyZSBsaWtlIHRoaXMuXG4vLyAgcmVzdWx0IG9mIGVhY2ggcm93L2NvbHVtbi9zbGFzaCBpcyA2IHdoZW4gWCB3aW5zLlxuLy9cdFxuLy8gICAgICA2ICAgIDYgICAgNiAgICA2XG4vLyAgICAgIFwiICAgIFwiICAgIFwiICAvLyAgICAgICAgXG4vL1x0ICAgIDIgfCAgMiAgfCAyICAgPSAgNlxuLy9cdCAtLS0tLSstLS0tLSstLS0tXG4vL1x0ICAgIDIgfCAgMiAgfCAyICAgPSAgNlxuLy9cdCAtLS0tLSstLS0tLSstLS0tXG4vLyAgICAgIDIgfCAgMiAgfCAyICAgPSAgNlxuLy8gICAgICBcbi8vIHNldHRpbmcgYWxsIE8gdG8gdmFsdWUgNSB3aWxsIG1ha2UgYSB3aW5uaW5nIG51bWJlciB0byAxNSBmcm9tIGFsbCBzaWRlcywgdW5sZXNzIHRoZXNlIHNldmVuIHJlc3VsdHMgXG4vLyBpcyBlcXVhbCB0byA2IG9yIDE1ICwgaXRzIGEgdGllIG1hdGNoLiBsZXRzIHNlZSBpZiB0aGUgZnVuY3Rpb24gd29ya3Mgb3Igbm90IC4uLi5cbi8vXG4vL1x0ICAgMTUgICAgMTUgICAxNSAgIDE1IFxuLy9cdCAgICBcIiAgICBcIiAgICBcIiAgLy9cbi8vXHQgICAgNSB8ICA1ICB8IDUgICAgPSAxNVxuLy9cdCAtLS0tLSstLS0tLSstLS0tXG4vL1x0ICAgIDUgfCAgNSAgfCA1ICAgID0gMTVcbi8vXHQgLS0tLS0rLS0tLS0rLS0tLVxuLy8gICAgICA1IHwgIDUgIHwgNSAgICA9IDE1XG5cblxuLy8gdGhpcyBmdW5jdGlvbiBoYW5kbGVzIHRoZSB3aW4gcmVzdWx0cyBpbnNpZGUgYSBwb3B1cDtcbnZhciBwb3BVcFdpbmRvdyA9IGZ1bmN0aW9uIChwbGF5ZXJJbWFnZVBvc2l0aW9uKSB7XG4gICAgbW9kYWxQYXJlbnQuc3R5bGUub3BhY2l0eSA9ICcxJztcbiAgICBtb2RhbFBhcmVudC5zdHlsZS56SW5kZXggPSAnMTAwJztcbiAgICBtb2RhbC5zdHlsZS56SW5kZXggPSAnMjAwJztcbiAgICBpZiAocGxheWVySW1hZ2VQb3NpdGlvbiA9PT0gJ3RpZScpIHtcbiAgICAgICAgbW9kYWwuZ2V0RWxlbWVudHNCeVRhZ05hbWUoJ2gyJylbMF0uaW5uZXJIVE1MID0gXCJJdCdzIGEgVGllXCI7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgbW9kYWwuZ2V0RWxlbWVudHNCeUNsYXNzTmFtZSgncGxheWVyLXdvbicpWzBdLnN0eWxlLmJhY2tncm91bmRQb3NpdGlvblggPSBwbGF5ZXJJbWFnZVBvc2l0aW9uO1xuICAgIH1cbiAgICBtb2RhbC5nZXRFbGVtZW50c0J5VGFnTmFtZSgnYnV0dG9uJylbMF0uYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHdpbmRvdy5sb2NhdGlvbi5yZWxvYWQodHJ1ZSk7XG4gICAgfSk7XG59O1xuXG5mdW5jdGlvbiB3aW5DaGVjaygpIHtcbiAgICB2YXIgcm93T25lXG4gICAgICAgID0gcGFyc2VJbnQoYm94WzBdLmRhdGFzZXQucGxheWVyVHlwZSlcbiAgICAgICAgKyBwYXJzZUludChib3hbMV0uZGF0YXNldC5wbGF5ZXJUeXBlKVxuICAgICAgICArIHBhcnNlSW50KGJveFsyXS5kYXRhc2V0LnBsYXllclR5cGUpO1xuICAgIHZhciByb3dUd29cbiAgICAgICAgPSBwYXJzZUludChib3hbM10uZGF0YXNldC5wbGF5ZXJUeXBlKVxuICAgICAgICArIHBhcnNlSW50KGJveFs0XS5kYXRhc2V0LnBsYXllclR5cGUpXG4gICAgICAgICsgcGFyc2VJbnQoYm94WzVdLmRhdGFzZXQucGxheWVyVHlwZSk7XG4gICAgdmFyIHJvd1RocmVlXG4gICAgICAgID0gcGFyc2VJbnQoYm94WzZdLmRhdGFzZXQucGxheWVyVHlwZSlcbiAgICAgICAgKyBwYXJzZUludChib3hbN10uZGF0YXNldC5wbGF5ZXJUeXBlKVxuICAgICAgICArIHBhcnNlSW50KGJveFs4XS5kYXRhc2V0LnBsYXllclR5cGUpO1xuICAgIHZhciBjb2xPbmVcbiAgICAgICAgPSBwYXJzZUludChib3hbMF0uZGF0YXNldC5wbGF5ZXJUeXBlKVxuICAgICAgICArIHBhcnNlSW50KGJveFszXS5kYXRhc2V0LnBsYXllclR5cGUpXG4gICAgICAgICsgcGFyc2VJbnQoYm94WzZdLmRhdGFzZXQucGxheWVyVHlwZSk7XG4gICAgdmFyIGNvbFR3b1xuICAgICAgICA9IHBhcnNlSW50KGJveFsxXS5kYXRhc2V0LnBsYXllclR5cGUpXG4gICAgICAgICsgcGFyc2VJbnQoYm94WzRdLmRhdGFzZXQucGxheWVyVHlwZSlcbiAgICAgICAgKyBwYXJzZUludChib3hbN10uZGF0YXNldC5wbGF5ZXJUeXBlKTtcbiAgICB2YXIgY29sVGhyZWVcbiAgICAgICAgPSBwYXJzZUludChib3hbMl0uZGF0YXNldC5wbGF5ZXJUeXBlKVxuICAgICAgICArIHBhcnNlSW50KGJveFs1XS5kYXRhc2V0LnBsYXllclR5cGUpXG4gICAgICAgICsgcGFyc2VJbnQoYm94WzhdLmRhdGFzZXQucGxheWVyVHlwZSk7XG4gICAgdmFyIGJhY2tTbGFzaFxuICAgICAgICA9IHBhcnNlSW50KGJveFswXS5kYXRhc2V0LnBsYXllclR5cGUpXG4gICAgICAgICsgcGFyc2VJbnQoYm94WzRdLmRhdGFzZXQucGxheWVyVHlwZSlcbiAgICAgICAgKyBwYXJzZUludChib3hbOF0uZGF0YXNldC5wbGF5ZXJUeXBlKTtcbiAgICB2YXIgZm9yd2FyZFNsYXNoXG4gICAgICAgID0gcGFyc2VJbnQoYm94WzJdLmRhdGFzZXQucGxheWVyVHlwZSlcbiAgICAgICAgKyBwYXJzZUludChib3hbNF0uZGF0YXNldC5wbGF5ZXJUeXBlKVxuICAgICAgICArIHBhcnNlSW50KGJveFs2XS5kYXRhc2V0LnBsYXllclR5cGUpO1xuXG4gICAgdmFyIHBvc3NpYmlsaXRpZXMgPSBbcm93T25lLCByb3dUd28sIHJvd1RocmVlLCBjb2xPbmUsIGNvbFR3bywgY29sVGhyZWUsIGJhY2tTbGFzaCwgZm9yd2FyZFNsYXNoXTtcblxuICAgIC8vIGxpa2UgZXhwbGFpbmVkIGFib3ZlIGNvbW1lbnRzIHdpdGggZGlhZ3JhbSwgYW55IGl0ZW0gZnJvbSB0aGUgYWJvdmUgYXJyYXkgc2hvdWxkIHJldHVybiAxIG9yIDIgaWYgYSBwbGF5ZXJcbiAgICAvLyB3aW5zLCBpdCBjYW4gcmV0dXJuIDIgYmVjYXVzZSBhIHBsYXllciBjYW4gc29tZXRpbWVzIHdpbiBmcm9tIDIgcG9zc2libGUgbGluZXMgbWF4aW11bTtcbiAgICB2YXIgeFdpbiA9IHBvc3NpYmlsaXRpZXMuZmlsdGVyKHNjb3BlID0+IHNjb3BlID09PSA2KTtcbiAgICB2YXIgb1dpbiA9IHBvc3NpYmlsaXRpZXMuZmlsdGVyKHNjb3BlID0+IHNjb3BlID09PSAxNSk7XG4gICAgdmFyIHRpZSAgPSBwb3NzaWJpbGl0aWVzLmZpbHRlcihzY29wZSA9PiBpc05hTihzY29wZSkpO1xuXG4gICAgLy8gbm93IHRha2UgY2FyZSBvZiB3aG8gd29uIHRoZSBnYW1lXG4gICAgaWYgKHhXaW4ubGVuZ3RoID09PSAxIHx8IHhXaW4ubGVuZ3RoID09PSAyKSB7XG4gICAgICAgIHBvcFVwV2luZG93KCcyMDAlJyk7XG4gICAgfSBlbHNlIGlmIChvV2luLmxlbmd0aCA9PT0gMSB8fCBvV2luLmxlbmd0aCA9PT0gMikge1xuICAgICAgICBwb3BVcFdpbmRvdygnMTAwJScpO1xuICAgIH0gZWxzZSBpZiAodGllLmxlbmd0aCA9PT0gMCAmJiB4V2luLmxlbmd0aCA9PT0gMCAmJiBvV2luLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICBwb3BVcFdpbmRvdygndGllJyk7XG4gICAgfVxuXG59XG5cbnZhciB0dXJuQ2hlY2sgPSBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICBpZiAoZXZlbnQudGFyZ2V0LmNsYXNzTGlzdC5jb250YWlucygnYm94JykpIHtcbiAgICAgICAgaWYgKGV2ZW50LnRhcmdldC5nZXRBdHRyaWJ1dGUoJ2RhdGEtcGxheWVyLXR5cGUnKSA9PT0gbnVsbCkge1xuICAgICAgICAgICAgZXZlbnQudGFyZ2V0LnNldEF0dHJpYnV0ZSgnZGF0YS1wbGF5ZXItdHlwZScsICh0dXJuICUgMiA9PT0gMCkgPyAyIDogNSk7XG4gICAgICAgICAgICBldmVudC50YXJnZXQuc3R5bGUuYmFja2dyb3VuZFBvc2l0aW9uID0gKHR1cm4gJSAyID09PSAwKSA/ICcyMDAlIDAnIDogJzEwMCUgMCc7XG4gICAgICAgICAgICB0dXJuKys7XG4gICAgICAgICAgICB3aW5DaGVjaygpO1xuICAgICAgICB9XG4gICAgfVxufTtcblxuYm9hcmQuYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLCB0dXJuQ2hlY2spO1xuXG4vLyBvbmx5IGZvciBwZXJzb25hbCBwb3J0Zm9saW8gcGFnZTtcbmRvY3VtZW50LmJvZHkuYWRkRXZlbnRMaXN0ZW5lcihcImRibGNsaWNrXCIsIGZ1bmN0aW9uIHJlbG9hZCgpIHtcbiAgICBsb2NhdGlvbi5yZWxvYWQodHJ1ZSk7XG59KTtcblxuLy8gcm90YXRlIHRoZSBib2FyZCB3aGVuIHdpbmRvdyBsb2FkcztcbnJvdGF0ZUJvYXJkKCk7XG4iXX0=
